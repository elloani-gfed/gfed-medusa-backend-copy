name: Manage Render Production Service

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to apply to production service'
        required: true
        type: choice
        default: auto
        options:
          - auto
          - suspend
          - resume
  # schedule:
  #   # Enforce policy every 30 minutes: :00-:29 resumed, :30-:59 suspended.
  #   - cron: '*/30 * * * *'

concurrency:
  group: render-prod-service-lifecycle
  cancel-in-progress: false

permissions:
  contents: read

env:
  RENDER_API_BASE_URL: https://api.render.com/v1
  RENDER_PROD_SERVICE_NAME: gfed-medusa-backend-prod
  RENDER_PROD_DATABASE_NAME: gfed-medusa-database
  SCHEDULE_TIMEZONE: Asia/Singapore

jobs:
  manage:
    name: Suspend/Resume Render prod service
    runs-on: ubuntu-latest
    environment: production-ops
    steps:
      - name: Determine desired action
        id: desired-action
        env:
          EVENT_NAME: ${{ github.event_name }}
          MANUAL_ACTION: ${{ github.event.inputs.action }}
          TIMEZONE: ${{ env.SCHEDULE_TIMEZONE }}
        run: |
          set -euo pipefail

          manual_action="${MANUAL_ACTION:-}"
          if [ "$EVENT_NAME" = "workflow_dispatch" ] && [ -n "$manual_action" ] && [ "$manual_action" != "auto" ]; then
            desired_action="$manual_action"
            reason="manual trigger"
          else
            minute_of_hour=$(TZ="$TIMEZONE" date +%M)
            minute_num=$((10#$minute_of_hour))
            local_timestamp=$(TZ="$TIMEZONE" date '+%Y-%m-%d %H:%M:%S %Z')

            if [ "$minute_num" -lt 30 ]; then
              desired_action="resume"
              reason="scheduled half-hour policy (:00-:29 resumed) at $local_timestamp"
            else
              desired_action="suspend"
              reason="scheduled half-hour policy (:30-:59 suspended) at $local_timestamp"
            fi
          fi

          echo "desired_action=$desired_action" >> "$GITHUB_OUTPUT"
          echo "reason=$reason" >> "$GITHUB_OUTPUT"
          echo "Action: $desired_action ($reason)" >> "$GITHUB_STEP_SUMMARY"

      - name: Resolve Render service ID
        id: resolve-service
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ env.RENDER_PROD_SERVICE_NAME }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
        run: |
          set -euo pipefail

          list_resp=$(
            curl -sS -w "\n%{http_code}" "$BASE_URL/services?name=$SERVICE_NAME&limit=1" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          list_body=$(echo "$list_resp" | head -n -1)
          list_status=$(echo "$list_resp" | tail -n 1)

          if [ "$list_status" -ge 300 ]; then
            echo "::error::Failed to query services ($list_status): $list_body"
            exit 1
          fi

          service_id=$(echo "$list_body" | jq -r '.[0].service.id // .[0].id // empty')

          if [ -z "$service_id" ]; then
            echo "::error::Service not found: $SERVICE_NAME"
            exit 1
          fi

          echo "service_id=$service_id" >> "$GITHUB_OUTPUT"
          echo "Service ID: $service_id" >> "$GITHUB_STEP_SUMMARY"

      - name: Resolve Render Postgres ID
        id: resolve-postgres
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          POSTGRES_NAME: ${{ env.RENDER_PROD_DATABASE_NAME }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
        run: |
          set -euo pipefail

          list_resp=$(
            curl -sS -w "\n%{http_code}" "$BASE_URL/postgres?name=$POSTGRES_NAME&limit=1" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          list_body=$(echo "$list_resp" | head -n -1)
          list_status=$(echo "$list_resp" | tail -n 1)

          if [ "$list_status" -ge 300 ]; then
            echo "::error::Failed to query Postgres instances ($list_status): $list_body"
            exit 1
          fi

          postgres_id=$(echo "$list_body" | jq -r '.[0].postgres.id // .[0].id // empty')

          if [ -z "$postgres_id" ]; then
            echo "::error::Postgres instance not found: $POSTGRES_NAME"
            exit 1
          fi

          echo "postgres_id=$postgres_id" >> "$GITHUB_OUTPUT"
          echo "Postgres ID: $postgres_id" >> "$GITHUB_STEP_SUMMARY"

      - name: Skip if service is already in desired state
        id: service-state-check
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
          SERVICE_ID: ${{ steps.resolve-service.outputs.service_id }}
          DESIRED_ACTION: ${{ steps.desired-action.outputs.desired_action }}
        run: |
          set -euo pipefail

          service_resp=$(
            curl -sS -w "\n%{http_code}" "$BASE_URL/services/$SERVICE_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          service_body=$(echo "$service_resp" | head -n -1)
          service_status=$(echo "$service_resp" | tail -n 1)

          if [ "$service_status" -ge 300 ]; then
            echo "::warning::Failed to inspect service state ($service_status): $service_body"
            echo "should_call=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          is_suspended=$(echo "$service_body" | jq -r '.suspended // .service.suspended // .serviceDetails.suspended // .service.serviceDetails.suspended // "unknown"')
          service_state=$(echo "$service_body" | jq -r '(.status // .service.status // .serviceDetails.status // .service.serviceDetails.status // "") | ascii_downcase')

          if [ "$is_suspended" != "true" ] && [ "$is_suspended" != "false" ]; then
            case "$service_state" in
              suspended|suspending|deactivated|paused)
                is_suspended="true"
                ;;
              live|running|active|ready|resuming)
                is_suspended="false"
                ;;
              *)
                is_suspended="unknown"
                ;;
            esac
          fi

          should_call="true"
          if [ "$DESIRED_ACTION" = "suspend" ] && [ "$is_suspended" = "true" ]; then
            should_call="false"
          fi
          if [ "$DESIRED_ACTION" = "resume" ] && [ "$is_suspended" = "false" ]; then
            should_call="false"
          fi

          echo "should_call=$should_call" >> "$GITHUB_OUTPUT"

          if [ "$should_call" = "false" ]; then
            if [ "$DESIRED_ACTION" = "suspend" ]; then
              echo "Service already suspended. Skipping suspend API call." >> "$GITHUB_STEP_SUMMARY"
            else
              echo "Service already running. Skipping resume API call." >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "Service state check: suspended=$is_suspended status=$service_state" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Skip if Postgres is already in desired state
        id: postgres-state-check
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
          POSTGRES_ID: ${{ steps.resolve-postgres.outputs.postgres_id }}
          DESIRED_ACTION: ${{ steps.desired-action.outputs.desired_action }}
        run: |
          set -euo pipefail

          postgres_resp=$(
            curl -sS -w "\n%{http_code}" "$BASE_URL/postgres/$POSTGRES_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          postgres_body=$(echo "$postgres_resp" | head -n -1)
          postgres_status=$(echo "$postgres_resp" | tail -n 1)

          if [ "$postgres_status" -ge 300 ]; then
            echo "::warning::Failed to inspect Postgres state ($postgres_status): $postgres_body"
            echo "should_call=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          postgres_suspended=$(echo "$postgres_body" | jq -r '.suspended // .postgres.suspended // "unknown"')
          postgres_runtime_status=$(echo "$postgres_body" | jq -r '(.status // .postgres.status // "") | ascii_downcase')

          case "$postgres_suspended" in
            suspended|true)
              is_suspended="true"
              ;;
            not_suspended|false)
              is_suspended="false"
              ;;
            *)
              case "$postgres_runtime_status" in
                suspended|suspending|deactivated|paused)
                  is_suspended="true"
                  ;;
                available|live|running|active|ready|resuming)
                  is_suspended="false"
                  ;;
                *)
                  is_suspended="unknown"
                  ;;
              esac
              ;;
          esac

          should_call="true"
          if [ "$DESIRED_ACTION" = "suspend" ] && [ "$is_suspended" = "true" ]; then
            should_call="false"
          fi
          if [ "$DESIRED_ACTION" = "resume" ] && [ "$is_suspended" = "false" ]; then
            should_call="false"
          fi

          echo "should_call=$should_call" >> "$GITHUB_OUTPUT"

          if [ "$should_call" = "false" ]; then
            if [ "$DESIRED_ACTION" = "suspend" ]; then
              echo "Postgres already suspended. Skipping suspend API call." >> "$GITHUB_STEP_SUMMARY"
            else
              echo "Postgres already running. Skipping resume API call." >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "Postgres state check: suspended=$is_suspended status=$postgres_runtime_status" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Trigger Render suspend/resume action
        if: steps.service-state-check.outputs.should_call == 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
          SERVICE_ID: ${{ steps.resolve-service.outputs.service_id }}
          ACTION: ${{ steps.desired-action.outputs.desired_action }}
          REASON: ${{ steps.desired-action.outputs.reason }}
        run: |
          set -euo pipefail

          action_resp=$(
            curl -sS -w "\n%{http_code}" -X POST "$BASE_URL/services/$SERVICE_ID/$ACTION" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          action_body=$(echo "$action_resp" | head -n -1)
          action_status=$(echo "$action_resp" | tail -n 1)

          if [ "$action_status" -ge 300 ]; then
            action_message=$(echo "$action_body" | jq -r '(.message // .error // .error.message // .details // empty) | tostring | ascii_downcase')
            if echo "$action_message" | grep -q "already"; then
              echo "::notice::Render reports service is already in the requested state."
              echo "Render replied that service is already in the requested state." >> "$GITHUB_STEP_SUMMARY"
              exit 0
            fi
            if [ "$ACTION" = "resume" ] && echo "$action_message" | grep -q "only services suspended by a user can be resumed"; then
              echo "::notice::Render reports service is not user-suspended; resume API call is a no-op."
              echo "Render replied that the service is not user-suspended; treating resume as a no-op." >> "$GITHUB_STEP_SUMMARY"
              exit 0
            fi

            echo "::error::Failed to $ACTION service ($action_status): $action_body"
            exit 1
          fi

          echo "Successfully requested '$ACTION' for service $SERVICE_ID ($REASON)." >> "$GITHUB_STEP_SUMMARY"

      - name: Trigger Render Postgres suspend/resume action
        if: steps.postgres-state-check.outputs.should_call == 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BASE_URL: ${{ env.RENDER_API_BASE_URL }}
          POSTGRES_ID: ${{ steps.resolve-postgres.outputs.postgres_id }}
          ACTION: ${{ steps.desired-action.outputs.desired_action }}
          REASON: ${{ steps.desired-action.outputs.reason }}
        run: |
          set -euo pipefail

          action_resp=$(
            curl -sS -w "\n%{http_code}" -X POST "$BASE_URL/postgres/$POSTGRES_ID/$ACTION" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          action_body=$(echo "$action_resp" | head -n -1)
          action_status=$(echo "$action_resp" | tail -n 1)

          if [ "$action_status" -ge 300 ]; then
            action_message=$(echo "$action_body" | jq -r '(.message // .error // .error.message // .details // empty) | tostring | ascii_downcase')
            if echo "$action_message" | grep -Eq "already|not suspended|not_suspended"; then
              echo "::notice::Render Postgres reports database is already in the requested state."
              echo "Render Postgres replied that database is already in the requested state." >> "$GITHUB_STEP_SUMMARY"
              exit 0
            fi

            echo "::error::Failed to $ACTION Postgres instance ($action_status): $action_body"
            exit 1
          fi

          echo "Successfully requested '$ACTION' for Postgres $POSTGRES_ID ($REASON)." >> "$GITHUB_STEP_SUMMARY"
